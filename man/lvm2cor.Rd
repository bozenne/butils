% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/lvmCov2Cor.R
\name{lvm2cor}
\alias{lvm2cor}
\alias{lvmCov2Cor}
\title{Covariance To Correlation Coefficient in LVM}
\usage{
lvmCov2Cor(
  object,
  var1,
  var2,
  null = 0,
  level = 0.95,
  FUN = NULL,
  FUN.args = NULL
)
}
\arguments{
\item{object}{a latent variable model (\code{lvmfit} object).}

\item{var1}{the name of a latent or endogenous variable.}

\item{var2}{the name of another latent or endogenous variable.}

\item{level}{the confidence level used for the confidence interval.}

\item{FUN}{the function used to compute the correlation. Alternative to the arguments var1 and var2.}

\item{FUN.args}{names of the coefficients used in FUN.}
}
\value{
A data.frame containing in the fourth row the estimated correlation coefficient, standard error, confidence intervals, and p.value.
}
\description{
Convert a covariance coefficient into a correlation coefficient in a lvm.
Uses a delta method to compute the variance, confidence interval, and p-value associated with the test of no correlation.
}
\details{
WARNING by default, this function will "just" convert a covariance coefficient into a correlation coefficient,
i.e. divide it by the standard deviation of the corresponding variables.
It will **not** output the "global" correlation when the covariance is modeled through several parameters in the LVM (e.g. through a Latent Variable plus a specific covariance parameter).
}
\examples{
#### Simulate some data ####
library(lava)
mSim <-lvm(c(PEQ_poslife,PEQ_posself,PEQ_posmood,PEQ_possoc,PEQ_posbehav)~lv.peq,
           c(MEQ_mystical,MEQ_mood) ~ 1*lv.meq,
           c(MEQ_timespace,MEQ_ineffability) ~ lv.meq,
lv.meq[0:2]~1,
lv.peq[0:0.25]~1)
covariance(mSim) <- lv.peq ~ lv.meq
covariance(mSim) <- MEQ_timespace~MEQ_ineffability
latent(mSim) <- ~lv.peq+lv.meq

set.seed(10)
GS <- sim(mSim, 1e5, latent = TRUE) ## not observed
set.seed(10)
d <- sim(mSim, 1e3, latent = FALSE) ##  observed

#### Fit the lvm ####
m1 <-lvm(c(PEQ_poslife,PEQ_posself,PEQ_posmood,PEQ_possoc,PEQ_posbehav)~lv.peq,
         c(MEQ_mystical,MEQ_mood) ~ 1*lv.meq,
         c(MEQ_timespace,MEQ_ineffability) ~ lv.meq)
covariance(m1) <- lv.peq ~ lv.meq
covariance(m1) <- MEQ_timespace~MEQ_ineffability
latent(m1) <- ~lv.peq + lv.meq
e <- estimate(m1, d)

#### Delta method for the correlation between the LVs ####
## approximated true value
c("var.meq" = var(GS$lv.meq), "var.peq" = var(GS$lv.peq),
  "cov" = cov(GS$lv.meq,GS$lv.peq), "cor" = cor(GS$lv.meq,GS$lv.peq))

## using lava
estimate(e, function(x){
a <- x["lv.meq~~lv.meq"]
b <- x["lv.peq~~lv.peq"]
c <- x["lv.peq~~lv.meq"]
  c(var.meq = a,
   var.peq = b,
   cov = c,
   cor = c/sqrt(a*b))
})

## Delta method via lvmCov2Cor
lvmCov2Cor(e, var1 = "lv.meq", var2 = "lv.peq")
lvmCov2Cor(e, FUN = function(x){x["lv.peq~~lv.meq"]/sqrt(x["lv.peq~~lv.peq"]*x["lv.meq~~lv.meq"])})

#### Delta method for the correlation between endogenous ####
## approximated true value
c("var.meq" = var(GS$MEQ_timespace), "var.peq" = var(GS$MEQ_ineffability),
  "cov" = cov(GS$MEQ_timespace,GS$MEQ_ineffability),
  "cor" = cor(GS$MEQ_timespace,GS$MEQ_ineffability))

## using lava (partial correlation)
estimate(e, function(x){
a <- x["MEQ_timespace~~MEQ_timespace"]
b <- x["MEQ_ineffability~~MEQ_ineffability"]
c <- x["MEQ_timespace~~MEQ_ineffability"]
  c(var.meq = a,
   var.peq = b,
   cov = c,
   cor = c/sqrt(a*b))
})

## Delta method via lvmCov2Cor (partial correlation)
lvmCov2Cor(e, var1 = "MEQ_timespace", var2 = "MEQ_ineffability")

## ERROR as no (direct) covariance parameter
## lvmCov2Cor(e, var1 = "PEQ_poslife", var2 = "PEQ_posself")

## Delta method via lvmCov2Cor (full correlation)
lvmCov2Cor(e, FUN = function(x){
sigma1 <- x["MEQ_timespace~~MEQ_timespace"]
sigma2 <- x["MEQ_ineffability~~MEQ_ineffability"]
sigma12 <- x["MEQ_timespace~~MEQ_ineffability"]
lambda1 <- x["MEQ_timespace~lv.meq"]
lambda2 <- x["MEQ_ineffability~lv.meq"]
tau <- x["lv.meq~~lv.meq"]

Sigma1 <- sigma1 + lambda1^2*tau
Sigma2  <- sigma2 + lambda2^2*tau

return((sigma12+lambda1*lambda2*tau)/sqrt(Sigma1*Sigma2))
})

}
